{"README.md":"\n> Open this page at GitHub Pages: [https://jp-rad.github.io/pxt-ubit-extension/](https://jp-rad.github.io/pxt-ubit-extension/)\n\n## Creating Extensions\n\nExtensions are PXTâ€™s dynamic/static library mechanism for extending a target, such as the pxt-micro:bit:\n\n* [MakeCode extensions](https://makecode.com/extensions)\n\n### Use this template\n\n* open the repository on github.  \n[https://github.com/jp-rad/pxt-ubit-extension](https://github.com/jp-rad/pxt-ubit-extension)\n* click **Use this template**.  \n[Here - https://github.com/jp-rad/pxt-ubit-extension/generate](https://github.com/jp-rad/pxt-ubit-extension/generate)\n* settings for your new repository.  \nSettings > Actions > General > Workflow permissions: **Read and write permissions**  \nSettings > Pages > branch: **master**\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/jp-rad/pxt-ubit-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/jp-rad/pxt-ubit-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/jp-rad/pxt-ubit-extension** and click import\n\n## Blocks preview\n\n<!--\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-ubit-extension/raw/master/.github/makecode/blocks.png)\n-->\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-ubit-extension/raw/master/.github/statics/blocks.png)\n\n\n### Blocks embed\n\n[https://makecode.microbit.org/blocks-embed](https://makecode.microbit.org/blocks-embed)\n\nCopy the following text at the bottom of your README.md file.\n\n```\n\n<script src=\"https://cdn.jsdelivr.net/gh/jp-rad/pxt-ubit-extension@0.5.0/.github/statics/gh-pages-embed.js\"></script>\n<script>makeCodeRender(\"{{ site.makecode.home_url }}\", [ \"custom=github:jp-rad/pxt-ubit-extension\", ]);</script>\n\n```\n\n### `blocks`\n\n**Example1**\n\n```blocks\ncustom.foo(4, \"Hello\", MyEnum.One)\n\n```\n\n\n**Example2**\n\n```blocks\ninput.onButtonPressed(Button.A, function () {\n    basic.showNumber(custom.baz())\n})\ninput.onButtonPressed(Button.B, function () {\n    basic.showNumber(custom.bar())\n})\n\n```\n\n## Downloaded HEX file to Use as Extension\n\nReleased HEX file can be imported as an **extension** in MakeCode.\n\n* open [https://github.com/jp-rad/pxt-ubit-extension/releases](https://github.com/jp-rad/pxt-ubit-extension/releases)\n* download HEX file\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* click on **Import File**\n* select downloaded HEX file and click on **Go ahead!**\n\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n\n<script src=\"https://cdn.jsdelivr.net/gh/jp-rad/pxt-ubit-extension@0.5.0/.github/statics/gh-pages-embed.js\"></script>\n<script>makeCodeRender(\"{{ site.makecode.home_url }}\", [ \"custom=github:jp-rad/pxt-ubit-extension\", ]);</script>\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n// Auto-generated. Do not edit. Really.\n","pxt.json":"{\n    \"name\": \"pxt-accelmagiq-estimator\",\n    \"version\": \"0.1.0\",\n    \"description\": \"A Simplified Analytic Attitude Determination Algorithm Using Accelerometer and Magnetometer on micro:bit.\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"src/lib/AccelMagiQLibCoordinateSpaceFilter.h\",\n        \"src/lib/AccelMagiQLibCoordinateSpaceFilter.cpp\",\n        \"src/lib/AccelMagiQLibQuaternionEstimator.h\",\n        \"src/lib/AccelMagiQLibQuaternionEstimator.cpp\",\n        \"src/accelmagiq_.cpp\",\n        \"src/accelmagiq_.ts\",\n        \"src/accelmagiq.ts\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test/test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"6.0.17\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n// Auto-generated. Do not edit. Really.\n","src/accelmagiq.ts":"/**\n * A Simplified Analytic Attitude Determination Algorithm\n * using Accelerometer and Magnetometer on micro:bit.\n * \n * It's like magic! This algorithm turns raw data into accurate and efficient quaternion estimations,\n * transforming your projects and making you go, \"Wow!\" Using the handy micro:bit, it feels like trying\n * out quaternions is pure magic. AccelMagiQ brings a touch of enchantment to the technical world.\n * We hope this helps you in your learning journey and sparks your curiosity about the fascinating\n * world of quaternions.\n * \n * \"AccelMagiQ\" refers to this amazing algorithm that combines accelerometer and magnetometer data to\n * create precise quaternion calculations. It's a playful blend of 'acceleration', 'magnetometer', and 'magic' with\n * quaternions ('Q'), making advanced concepts seem like magic!\n */\n//% block=\"AccelMagiQ\"\n//% weight=95 color=#4b0082 icon=\"\\uf1d8\"\n//% groups=\"['Quaternion', 'EulerAngles', 'Sensor', 'Service']\"\nnamespace accelmagiq {\n\n    /** \n     * Define the EstimationMethod enum\n     */\n    export enum EstimationMethod {\n        /**\n         * FAMC estimation method\n         */\n        //% block=\"FAMC\"\n        FAMC = 0,\n        /**\n         * SIMPLE estimation method\n         */\n        //% block=\"SIMPLE\"\n        SIMPLE = 1\n    }\n\n    /**\n     * Define coordinate system enum\n     */\n    export enum CoordinateSystem {\n        /**\n         * BASIC: a non-tilt compensated bearing of the device (North: logo mark)\n         */\n        //% block=\"BASIC\"\n        BASIC = 0,\n        /**\n         * TILT: a tilt compensated bearing of the device (North: back side)\n         */\n        //% block=\"TILT\"\n        TILT = 1,\n        /**\n         * RAW: a raw coordinate system (North: A-button, upside-down)\n         */\n        //% block=\"RAW\"\n        RAW = 2,\n    }\n\n    /**\n     * Estimates the current quaternion.\n     * @returns An array containing the quaternion components [w, x, y, z].\n     */\n    //% block=\"estimate quaternion\"\n    //% group=\"Sensor\"\n    //% weight=105\n    export function estimate(): number[] {\n        accelmagiq_.estimate();\n        return [accelmagiq_.getW(), accelmagiq_.getX(), accelmagiq_.getY(), accelmagiq_.getZ()];\n    }\n\n    /**\n     * Sets the coordinate system.\n     */\n    //% block=\"set coordinate system %system\"\n    //% group=\"Sensor\"\n    //% weight=104\n    export function setCoordinateSystem(system: CoordinateSystem) {\n        accelmagiq_.setCoordinateSystem(system);\n    }\n\n    /**\n     * Sets the alpha value for the low-pass filter.\n     * @param alpha The new alpha value (between 0.0 and 1.0). Default is 0.3.\n     */\n    //% block=\"set alpha %alpha\"\n    //% group=\"Sensor\"\n    //% weight=103\n    //% alpha.defl=0.3\n    //% advanced=true\n    export function setAlpha(alpha: number): void {\n        accelmagiq_.setLowPassFilterAlpha(alpha);\n    }\n\n    /**\n     * Start sampling.\n     * @returns An array containing the quaternion components [w, x, y, z].\n     */\n    //% block=\"start sampling\"\n    //% group=\"Sensor\"\n    //% weight=102\n    //% advanced=true\n    export function startSampling(): void {\n        accelmagiq_.startSampling();\n    }\n\n    /**\n     * Stop sampling.\n     */\n    //% block=\"stop sampling\"\n    //% group=\"Sensor\"\n    //% weight=101\n    //% advanced=true\n    export function stopSampling(): void {\n        accelmagiq_.stopSampling();\n    }\n\n    /**\n     * Sets the estimation method.\n     */\n    //% block=\"set estimate method %method\"\n    //% group=\"Sensor\"\n    //% weight=100\n    //% advanced=true\n    export function setEstimateMethod(method: EstimationMethod): void {\n        accelmagiq_.setEstimateMethod(method);\n    }\n    \n}\n","src/accelmagiq_.cpp":"#include \"pxt.h\"\r\n#include \"lib/AccelMagiQLibQuaternionEstimator.h\"\r\n\r\nusing namespace accelmagiqlib;\r\n\r\nnamespace accelmagiq_\r\n{\r\n\r\n    static QuaternionEstimator *_pQuaternionEstimator = nullptr;\r\n    QuaternionEstimator &instance()\r\n    {\r\n        if (nullptr == _pQuaternionEstimator)\r\n            _pQuaternionEstimator = new QuaternionEstimator();\r\n        return *_pQuaternionEstimator;\r\n    }\r\n\r\n    //%\r\n    void setCoordinateSystem(int system)\r\n    {\r\n        instance().setCoordinateSystem(system);\r\n    }\r\n\r\n    //%\r\n    void setLowPassFilterAlpha(TNumber alpha)\r\n    {\r\n        instance().setLowPassFilterAlpha(toDouble(alpha));\r\n    }\r\n\r\n    //%\r\n    void setEstimateMethod(int method)\r\n    {\r\n        instance().setEstimateMethod(method);\r\n    }\r\n\r\n    //%\r\n    void startSampling()\r\n    {\r\n        instance().resumeSampling();\r\n    }\r\n\r\n    //%\r\n    void stopSampling()\r\n    {\r\n        instance().pauseSampling();\r\n    }\r\n\r\n    //%\r\n    void estimate()\r\n    {\r\n        instance().estimate();\r\n    }\r\n\r\n    //%\r\n    TNumber getW()\r\n    {\r\n        return fromDouble(instance().getW());\r\n    }\r\n\r\n    //%\r\n    TNumber getX()\r\n    {\r\n        return fromDouble(instance().getX());\r\n    }\r\n\r\n    //%\r\n    TNumber getY()\r\n    {\r\n        return fromDouble(instance().getY());\r\n    }\r\n\r\n    //%\r\n    TNumber getZ()\r\n    {\r\n        return fromDouble(instance().getZ());\r\n    }\r\n\r\n}\r\n","src/accelmagiq_.ts":"namespace accelmagiq_ {\n\n    // Accelerration (normalized) for simulator\n    let rawAx = 1.0;\n    let rawAy = 0.0;\n    let rawAz = 0.0;\n\n    // Quaternion for simulator\n    let q_ = [1.0, 0.0, 0.0, 0.0];\n\n    // coordinateSystem for simulator\n    let coordinateSystem_ = 0;\n\n    //% shim=accelmagiq_::setCoordinateSystem\n    export function setCoordinateSystem(system: number) {\n        // alpha for simulator\n        coordinateSystem_ = system;\n    }\n\n    // alpha for simulator\n    let alpha_ = 1.0;\n\n    //% shim=accelmagiq_::setLowPassFilterAlpha\n    export function setLowPassFilterAlpha(alpha: number): void {\n        // for simulator\n        alpha_ = alpha;\n    }\n\n    // method for simulator\n    let method_ = 0;\n\n    //% shim=accelmagiq_::setEstimateMethod\n    export function setEstimateMethod(method: number): void {\n        // for simulator\n        method_ = method;\n    }\n\n    // sampling for simulator\n    let sampling_ = true;   // auto start\n\n    //% shim=accelmagiq_::startSampling\n    export function startSampling(): void {\n        // for simulator\n        sampling_ = true;\n    }\n\n\n    //% shim=accelmagiq_::startSampling\n    export function stopSampling(): void {\n        // for simulator\n        sampling_ = false;\n    }\n\n    // for simulator\n    function readAcceleration(): void {\n        const x = input.acceleration(Dimension.X);\n        const y = input.acceleration(Dimension.Y);\n        const z = input.acceleration(Dimension.Z);\n\n        let norm = Math.sqrt(x * x + y * y + z * z)\n        if (0 < norm) {\n            norm = 1 / norm;\n            rawAx = x * norm;\n            rawAy = y * norm;\n            rawAz = z * norm;\n        }\n    }\n\n    //% shim=accelmagiq_::estimate\n    export function estimate(): void {\n        // for simulator\n        if (sampling_) {\n            readAcceleration();\n        }\n        const ax = rawAy;\n        const ay = rawAx;\n        const az = -rawAz;\n\n        let w = Math.sqrt((az + 1.0) / 2.0)\n        let x = ay / (2.0 * w)\n        let y = -ax / (2.0 * w)\n        let z = 0.0\n        let norm = Math.sqrt(w * w + x * x + y * y + z * z)\n        if (0 < norm) {\n            norm = 1 / norm;\n            w *= norm;\n            x *= norm;\n            y *= norm;\n            z *= norm;\n            q_ = [w, x, y, z];\n        }\n    }\n\n    //% shim=accelmagiq_::getW\n    export function getW(): number {\n        // for simulator\n        return q_[0];\n    }\n\n    //% shim=accelmagiq_::getX\n    export function getX(): number {\n        // for simulator\n        return q_[1];\n    }\n\n    //% shim=accelmagiq_::getY\n    export function getY(): number {\n        // for simulator\n        return q_[2];\n    }\n\n    //% shim=accelmagiq_::getZ\n    export function getZ(): number {\n        // for simulator\n        return q_[3];\n    }\n\n}\n","src/lib/AccelMagiQLibCoordinateSpaceFilter.cpp":"#include \"AccelMagiQLibCoordinateSpaceFilter.h\"\n\nusing namespace accelmagiqlib;\n\n    void CoordinateSpaceFilter::setCoordinateSystem(const int system)\n    {\n        currentSystem = system;\n    }\n\n    double CoordinateSpaceFilter::getCoordX() const\n    {\n        if (currentSystem == COORDINATE_SYSTEM_BASIC)\n            return rawY;\n        if (currentSystem == COORDINATE_SYSTEM_TILT)\n            return rawZ;\n        return rawX;\n    }\n\n    double CoordinateSpaceFilter::getCoordY() const\n    {\n        if (currentSystem == COORDINATE_SYSTEM_BASIC)\n            return rawX;\n        if (currentSystem == COORDINATE_SYSTEM_TILT)\n            return rawX;\n        return rawY;\n    }\n\n    double CoordinateSpaceFilter::getCoordZ() const\n    {\n        if (currentSystem == COORDINATE_SYSTEM_BASIC)\n            return -rawZ;\n        if (currentSystem == COORDINATE_SYSTEM_TILT)\n            return rawY;\n        return rawZ;\n    }\n\n    void CoordinateSpaceFilter::update(const double x, const double y, const double z)\n    {\n        // Use the inline low-pass filter to update the raw values\n        prevX = lowPassFilter(x, prevX, alphaX, oneMinusAlphaX);\n        prevY = lowPassFilter(y, prevY, alphaY, oneMinusAlphaY);\n        prevZ = lowPassFilter(z, prevZ, alphaZ, oneMinusAlphaZ);\n        double norm = std::sqrt(prevX * prevX + prevY * prevY + prevZ * prevZ);\n        if (0.0 < norm)\n        {\n            rawX = prevX / norm;\n            rawY = prevY / norm;\n            rawZ = prevZ / norm;\n        }\n    }\n\n    void CoordinateSpaceFilter::setAlpha(const double alpha)\n    {\n        alphaX = alpha;\n        oneMinusAlphaX = 1.0 - alpha;\n        alphaY = alpha;\n        oneMinusAlphaY = 1.0 - alpha;\n        alphaZ = alpha;\n        oneMinusAlphaZ = 1.0 - alpha;\n    }\n\n    inline double CoordinateSpaceFilter::lowPassFilter(double newValue, double &oldValue, double alpha, double oneMinusAlpha)\n    {\n        oldValue = alpha * newValue + oneMinusAlpha * oldValue;\n        return oldValue;\n    }\n","src/lib/AccelMagiQLibCoordinateSpaceFilter.h":"#ifndef ACCELMAGIQLIB_COORDINATESPACEFILTER_H\n#define ACCELMAGIQLIB_COORDINATESPACEFILTER_H\n\n#include <cmath>\n\nnamespace accelmagiqlib\n{\n\n    // Define coordinate system constants\n    const int COORDINATE_SYSTEM_BASIC = 0; /**< BASIC: a non-tilt compensated bearing of the device (North: logo mark) */\n    const int COORDINATE_SYSTEM_TILT = 1;  /**< TILT: a tilt compensated bearing of the device (North: back side) */\n    const int COORDINATE_SYSTEM_RAW = 2;   /**< RAW: a raw coordinate system (North: A-button, upside-down) */\n\n    /**\n     * @class CoordinateSpaceFilter\n     * @brief A class to filter and manage coordinates with low-pass filtering and different coordinate systems.\n     */\n    class CoordinateSpaceFilter\n    {\n    private:\n        int currentSystem; /**< The current coordinate system being used */\n\n        // Low-pass filter parameters\n        double alphaX;          /**< Alpha value for low-pass filter on X-axis */\n        double oneMinusAlphaX;  /**< Precomputed (1.0 - alphaX) value */\n        double alphaY;          /**< Alpha value for low-pass filter on Y-axis */\n        double oneMinusAlphaY;  /**< Precomputed (1.0 - alphaY) value */\n        double alphaZ;          /**< Alpha value for low-pass filter on Z-axis */\n        double oneMinusAlphaZ;  /**< Precomputed (1.0 - alphaZ) value */\n        double prevX;           /**< Previous filtered value for X-axis */\n        double prevY;           /**< Previous filtered value for Y-axis */\n        double prevZ;           /**< Previous filtered value for Z-axis */\n\n        // Normalized coordinates\n        double rawX; /**< Normalized X coordinate */\n        double rawY; /**< Normalized Y coordinate */\n        double rawZ; /**< Normalized Z coordinate */\n\n    public:\n        static constexpr double DEFAULT_ALPHA = 0.3; /**< Default alpha value for the low-pass filter */\n\n        /**\n         * Constructor to initialize the CoordinateSpaceFilter with initial coordinates\n         * and an optional alpha value for the low-pass filter.\n         *\n         * @param x Initial X coordinate (default is 0.0).\n         * @param y Initial Y coordinate (default is 0.0).\n         * @param z Initial Z coordinate (default is 0.0).\n         * @param system The coordinate system to use:\n         *               - COORDINATE_SYSTEM_BASIC: 0 (default)\n         *               - COORDINATE_SYSTEM_TILT: 1\n         *               - COORDINATE_SYSTEM_RAW: 2\n         * @param alpha Alpha value for the low-pass filter (default is 0.3).\n         */\n        CoordinateSpaceFilter(const double x = 0.0, const double y = 0.0, const double z = 0.0,\n                              const int system = COORDINATE_SYSTEM_BASIC, const double alpha = DEFAULT_ALPHA)\n            : currentSystem(system),\n              alphaX(alpha), oneMinusAlphaX(1.0 - alpha),\n              alphaY(alpha), oneMinusAlphaY(1.0 - alpha),\n              alphaZ(alpha), oneMinusAlphaZ(1.0 - alpha),\n              prevX(x), prevY(y), prevZ(z),\n              rawX(0.0), rawY(0.0), rawZ(0.0)\n        {\n            update(x, y, z);\n        }\n\n        /**\n         * Sets the coordinate system for the filter.\n         *\n         * @param system The coordinate system to use:\n         *               - COORDINATE_SYSTEM_BASIC: 0\n         *               - COORDINATE_SYSTEM_TILT: 1\n         *               - COORDINATE_SYSTEM_RAW: 2\n         */\n        void setCoordinateSystem(const int system);\n\n        /**\n         * Gets the X coordinate based on the current coordinate system.\n         *\n         * @return The X coordinate value.\n         */\n        double getCoordX() const;\n\n        /**\n         * Gets the Y coordinate based on the current coordinate system.\n         *\n         * @return The Y coordinate value.\n         */\n        double getCoordY() const;\n\n        /**\n         * Gets the Z coordinate based on the current coordinate system.\n         *\n         * @return The Z coordinate value.\n         */\n        double getCoordZ() const;\n\n        /**\n         * Updates the coordinate values with new data.\n         *\n         * @param x The new X value.\n         * @param y The new Y value.\n         * @param z The new Z value.\n         */\n        void update(const double x, const double y, const double z);\n\n        /**\n         * Sets the alpha value for the low-pass filter.\n         *\n         * @param alpha The new alpha value.\n         */\n        void setAlpha(const double alpha);\n\n    private:\n        /**\n         * Applies a low-pass filter to the given value.\n         *\n         * @param newValue The new value to filter.\n         * @param oldValue The previous filtered value.\n         * @param alpha The alpha value for the filter.\n         * @param oneMinusAlpha Precomputed (1.0 - alpha) value.\n         * @return The filtered value.\n         */\n        inline double lowPassFilter(double newValue, double &oldValue, double alpha, double oneMinusAlpha);\n    };\n\n} // namespace accelmagiqlib\n\n#endif // ACCELMAGIQLIB_COORDINATESPACEFILTER_H\n","src/lib/AccelMagiQLibQuaternionEstimator.cpp":"#include \"AccelMagiQLibQuaternionEstimator.h\"\n#include <cmath>\n\nusing namespace accelmagiqlib;\n\ndouble QuaternionEstimator::getW() const\n{\n    return qw;\n}\n\ndouble QuaternionEstimator::getX() const\n{\n    return qx;\n}\n\ndouble QuaternionEstimator::getY() const\n{\n    return qy;\n}\n\ndouble QuaternionEstimator::getZ() const\n{\n    return qz;\n}\n\nvoid QuaternionEstimator::setLowPassFilterAlpha(const double alpha)\n{\n    filterAccel.setAlpha(alpha);\n    filterMagne.setAlpha(alpha);\n}\n\nvoid QuaternionEstimator::resumeSampling()\n{\n    isSampling = true;\n    if (isListen)\n        return;\n    isListen = true;\n    if (EventModel::defaultEventBus)\n    {\n        EventModel::defaultEventBus->listen(\n            MICROBIT_ID_ACCELEROMETER, MICROBIT_ACCELEROMETER_EVT_DATA_UPDATE,\n            this, &QuaternionEstimator::accelerometerUpdateHandler,\n            MESSAGE_BUS_LISTENER_DROP_IF_BUSY /** MAY BE DROPPED */);\n        EventModel::defaultEventBus->listen(\n            MICROBIT_ID_COMPASS, MICROBIT_COMPASS_EVT_DATA_UPDATE,\n            this, &QuaternionEstimator::magnetometerUpdateHandler,\n            MESSAGE_BUS_LISTENER_DROP_IF_BUSY /** MAY BE DROPPED */);\n    }\n}\n\nvoid QuaternionEstimator::pauseSampling()\n{\n    isSampling = false;\n#if MICROBIT_CODAL\n    if (!isListen)\n        return;\n    isListen = false;\n    if (EventModel::defaultEventBus)\n    {\n        EventModel::defaultEventBus->ignore(\n            MICROBIT_ID_ACCELEROMETER, MICROBIT_ACCELEROMETER_EVT_DATA_UPDATE,\n            this, &QuaternionEstimator::accelerometerUpdateHandler);\n        EventModel::defaultEventBus->ignore(\n            MICROBIT_ID_COMPASS, MICROBIT_COMPASS_EVT_DATA_UPDATE,\n            this, &QuaternionEstimator::magnetometerUpdateHandler);\n    }\n#endif // MICROBIT_CODAL\n}\n\nvoid QuaternionEstimator::accelerometerUpdateHandler(MicroBitEvent e)\n{\n    if (!isSampling)\n        return;\n    // Update and normalize accelerometer data\n    double x = uBit.accelerometer.getX();\n    double y = uBit.accelerometer.getY();\n    double z = uBit.accelerometer.getZ();\n    filterAccel.update(x, y, z);\n}\n\nvoid QuaternionEstimator::magnetometerUpdateHandler(MicroBitEvent e)\n{\n    if (!isSampling)\n        return;\n    // Update and normalize magnetometer data\n    double x = uBit.compass.getX();\n    double y = uBit.compass.getY();\n    double z = uBit.compass.getZ();\n    filterMagne.update(x, y, z);\n}\n\nvoid QuaternionEstimator::setEstimateMethod(const int method)\n{\n    currentMethod = method;\n}\n\nvoid QuaternionEstimator::setCoordinateSystem(const int system)\n{\n    filterAccel.setCoordinateSystem(system);\n    filterMagne.setCoordinateSystem(system);\n}\n\nvoid QuaternionEstimator::estimate()\n{\n    if (ESTIMATION_METHOD_FAMC == currentMethod)\n    {\n        estimateFamc();\n    }\n    else\n    {\n        estimateSimple();\n    }\n}\n\nvoid QuaternionEstimator::estimateFamc()\n{\n    const double ax = filterAccel.getCoordX();\n    const double ay = filterAccel.getCoordY();\n    const double az = filterAccel.getCoordZ();\n    const double mx = filterMagne.getCoordX();\n    const double my = filterMagne.getCoordY();\n    const double mz = filterMagne.getCoordZ();\n\n    // ---------------------------------------------------------------------------------------------\n    // A Simplified Analytic Attitude Determination Algorithm Using Accelerometer and Magnetometer\n    // Fast Accelerometer-Magnetometer Combination (FAMC) algorithm by Zhuohua Liu and Jin Wu\n    // ---------------------------------------------------------------------------------------------\n    // https://github.com/zarathustr/Analytic-AMC/blob/master/FAMC.m\n\n    // Dynamic magnetometer reference vector\n    double m_D = ax * mx + ay * my + az * mz;\n    double m_N = sqrt(1.0 - m_D * m_D);\n\n    // Parameters\n    double B11 = (m_N * mx) / 2.0;\n    double B13 = ax / 2.0 + (m_D * mx) / 2.0;\n    double B21 = (m_N * my) / 2.0;\n    double B23 = ay / 2.0 + (m_D * my) / 2.0;\n    double B31 = (m_N * mz) / 2.0;\n    double B33 = az / 2.0 + (m_D * mz) / 2.0;\n\n    double tau = B13 + B31;\n\n    // First Row\n    double p1 = B33 - B11 + 1.0;\n    double A11 = -1.0 / p1;\n    double A12 = B21 / p1;\n    double A13 = tau / p1;\n\n    // Second Row\n    double p2 = -B21 * B21 / p1 + B11 + B33 + 1.0;\n    double A21 = -B21 / (p1 * p2);\n    double A22 = -1.0 / p2;\n    double A23 = (B23 + B21 * tau / p1) / p2;\n\n    // Third Row\n    double p3 = p1 - 2.0 + tau * tau / p1 + A23 * A23 * p2;\n    double A31 = (tau / p1 + B21 * A23 / p1) / p3;\n    double A32 = A23 / p3;\n    double A33 = 1.0 / p3;\n\n    // Quaternion Elements\n    double a1 = B23 * (A11 + A12 * (A21 + A23 * A31) + A13 * A31);\n    double a2 = (B13 - B31) * (A21 + A23 * A31);\n    double a3 = A31 * B21;\n    double b1 = B23 * (A12 * (A22 + A23 * A32) + A13 * A32);\n    double b2 = (B13 - B31) * (A22 + A23 * A32);\n    double b3 = A32 * B21;\n    double c1 = B23 * (A13 * A33 + A12 * A23 * A33);\n    double c2 = A33 * B21;\n    double c3 = A23 * A33 * (B13 - B31);\n\n    // Quaternion\n    double w = -1.0;\n    double x = a1 - a2 - a3;\n    double y = b1 - b2 - b3;\n    double z = c1 - c2 - c3;\n\n    // Normalize the quaternion\n    double norm = sqrt(w * w + x * x + y * y + z * z);\n    if (0 < norm)\n    {\n        norm = 1 / norm;\n        qw = w * norm;\n        qx = x * norm;\n        qy = y * norm;\n        qz = z * norm;\n    }\n}\n\nvoid QuaternionEstimator::estimateSimple()\n{\n    const double ax = filterAccel.getCoordX();\n    const double ay = filterAccel.getCoordY();\n    const double az = filterAccel.getCoordZ();\n\n    // Accelerration Only\n    double w = std::sqrt((az + 1.0) / 2.0);\n    double x = ay / (2.0 * w);\n    double y = -ax / (2.0 * w);\n    double z = 0.0;\n\n    // normalize\n    double norm = sqrt(w * w + x * x + y * y + z * z);\n    if (0 < norm)\n    {\n        norm = 1 / norm;\n        qw = w * norm;\n        qx = x * norm;\n        qy = y * norm;\n        qz = z * norm;\n    }\n}\n","src/lib/AccelMagiQLibQuaternionEstimator.h":"#ifndef ACCELMAGIQLIB_QUATERNIONESTIMATOR_H\n#define ACCELMAGIQLIB_QUATERNIONESTIMATOR_H\n\n#include \"pxt.h\"\n#include \"AccelMagiQLibCoordinateSpaceFilter.h\"\n\nnamespace accelmagiqlib\n{\n\n    // The method identifier to use for estimation: 0-FAMC, 1-SIMPLE\n    const int ESTIMATION_METHOD_FAMC = 0;   /**< FAMC method */\n    const int ESTIMATION_METHOD_SIMPLE = 1; /**< Simple method */\n\n    /**\n     * @class QuaternionEstimator\n     * @brief This class estimates quaternion orientation based on accelerometer and magnetometer data.\n     */\n    class QuaternionEstimator\n    {\n    public:\n        /**\n         * @brief Constructor to initialize the QuaternionEstimator.\n         */\n        QuaternionEstimator()\n            : currentMethod(ESTIMATION_METHOD_FAMC),\n              isListen(false), isSampling(false),\n              filterAccel(), filterMagne(),\n              qw(1.0), qx(0.0), qy(0.0), qz(0.0)\n        {\n            resumeSampling();\n        }\n\n        // Getters for quaternion components\n        /**\n         * @brief Get the W component of the quaternion.\n         * @return The W component of the quaternion.\n         */\n        double getW() const;\n\n        /**\n         * @brief Get the X component of the quaternion.\n         * @return The X component of the quaternion.\n         */\n        double getX() const;\n\n        /**\n         * @brief Get the Y component of the quaternion.\n         * @return The Y component of the quaternion.\n         */\n        double getY() const;\n\n        /**\n         * @brief Get the Z component of the quaternion.\n         * @return The Z component of the quaternion.\n         */\n        double getZ() const;\n\n        /**\n         * @brief Set the alpha value for the low-pass filters.\n         * @param alpha The new alpha value. Should be in the range of 0.0 to 1.0.\n         */\n        void setLowPassFilterAlpha(const double alpha);\n\n        /**\n         * @brief Resume sampling sensor data.\n         */\n        void resumeSampling();\n\n        /**\n         * @brief Pause sampling sensor data.\n         */\n        void pauseSampling();\n\n    private:\n        bool isListen;   /**< listen/ignore defaultEventBus */\n        bool isSampling; /**< Indicates whether the sampling of sensor data is active */\n\n        /**\n         * @brief Callback for accelerometer updates.\n         * @param e The MicroBitEvent triggered by the accelerometer.\n         */\n        void accelerometerUpdateHandler(MicroBitEvent e);\n\n        /**\n         * @brief Callback for magnetometer updates.\n         * @param e The MicroBitEvent triggered by the magnetometer.\n         */\n        void magnetometerUpdateHandler(MicroBitEvent e);\n\n    public:\n        /**\n         * @brief Set the method used for quaternion estimation.\n         * @param method The method identifier to use for estimation: 0-FAMC, 1-SIMPLE.\n         */\n        void setEstimateMethod(const int method);\n\n        /**\n         * @brief Sets the coordinate system for the filter.\n         * @param system The coordinate system to use:\n         *               - COORDINATE_SYSTEM_BASIC: 0\n         *               - COORDINATE_SYSTEM_TILT: 1\n         *               - COORDINATE_SYSTEM_RAW: 2\n         */\n        void setCoordinateSystem(const int system);\n\n        /**\n         * @brief Perform the quaternion estimation.\n         *\n         * This function calculates the quaternion based on the current sensor data and the selected estimation method.\n         */\n        void estimate();\n\n    private:\n        /**\n         * @brief Estimate the quaternion using the Fast Accelerometer-Magnetometer Combination (FAMC) algorithm.\n         */\n        void estimateFamc();\n\n        /**\n         * @brief Estimate the quaternion using a simple method.\n         */\n        void estimateSimple();\n\n        // Estimation method\n        int currentMethod; /**< The currently selected method identifier to use for estimation: 0-FAMC, 1-SIMPLE */\n\n        // Acceleration filter\n        CoordinateSpaceFilter filterAccel; /**< Filter for accelerometer data */\n\n        // Magnetic force filter\n        CoordinateSpaceFilter filterMagne; /**< Filter for magnetometer data */\n\n        // Quaternion (normalized)\n        double qw; /**< W component of the quaternion */\n        double qx; /**< X component of the quaternion */\n        double qy; /**< Y component of the quaternion */\n        double qz; /**< Z component of the quaternion */\n    };\n\n} // namespace accelmagiqlib\n\n#endif // ACCELMAGIQLIB_QUATERNIONESTIMATOR_H\n","test/test.ts":"/**\n * tests go here; this will not be compiled when this package is used as an extension.\n */\ninput.onButtonPressed(Button.A, function () {\n    accelmagiq.setCoordinateSystem(accelmagiq.CoordinateSystem.BASIC)\n    basic.showLeds(`\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        `)\n})\ninput.onButtonPressed(Button.AB, function () {\n    accelmagiq.stopSampling()\n    input.calibrateCompass()\n    accelmagiq.startSampling()\n})\ninput.onButtonPressed(Button.B, function () {\n    accelmagiq.setCoordinateSystem(accelmagiq.CoordinateSystem.TILT)\n    basic.showLeds(`\n        . . . . .\n        . . # . .\n        # # # # #\n        . . # . .\n        . . . . .\n        `)\n})\nlet quat: number[] = []\nserial.redirectToUSB()\nserial.setBaudRate(BaudRate.BaudRate115200)\nserial.writeLine(\"*\")\nserial.writeLine(\"*\")\nserial.writeLine(\"*\")\nserial.writeLine(\"*\")\nserial.writeLine(\"AccelMagiQ1\")\nbasic.showLeds(`\n    . # # # .\n    # # . # .\n    # . . # .\n    # # # # #\n    . . . # .\n    `)\nbasic.forever(function () {\n    quat = accelmagiq.estimate()\n    serial.writeNumbers(quat)\n    basic.pause(200)\n})\n"}